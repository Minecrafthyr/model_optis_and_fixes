import zipfile
import os
import shutil


def zip_multiple_folders(folder_paths: list[str], zip_path: str):
    """
    Generated by AI

    :param folder_paths: 要压缩的文件夹路径列表
    :param zip_path: 压缩文件的保存路径（包含文件名和.zip扩展名）
    """
    # 临时数据结构，用于存储文件路径和内容
    temp_files = {}

    # 遍历每个文件夹，将文件内容存储到临时数据结构中
    for folder_path in folder_paths:
        # 确保文件夹存在
        if not os.path.exists(folder_path):
            print(f"文件夹 {folder_path} 不存在，将跳过!")
            continue

        for root, _, files in os.walk(folder_path):
            for file in files:
                # 获取源文件的完整路径
                file_path = os.path.join(root, file)
                # 计算相对路径
                relative_path = os.path.relpath(file_path, start=folder_path)
                # 读取文件内容并存储到临时数据结构中
                with open(file_path, "rb") as f:
                    temp_files[relative_path] = f.read()

    # 创建ZIP文件并将临时数据结构中的内容写入
    with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zipf:
        for relative_path, file_content in temp_files.items():
            # 将文件内容写入ZIP文件
            zipf.writestr(relative_path, file_content)

    print(f"所有文件夹的内容已成功压缩到 {zip_path}")


def pack(source, target):
    zip_multiple_folders(
        [os.path.join("Assets2", s) for s in source], f"ZippedPacks\\{target}.zip"
    )


if os.path.exists("ZippedPacks"):
    shutil.rmtree("ZippedPacks")
os.mkdir("ZippedPacks")

pack(["base"], "Resource Fixes Lite")
pack(["base", "full"], "Resource Fixes")
pack(["base", "full", "textured"], "Resource Fixes Textured")
pack(
    [
        "base",
        "full",
        "textured",
        "tweaks",
        "tweak_animation",
        "tweak_fire",
        "tweak_shadeless_lights",
        "tweak_wide_bamboo",
    ],
    "Resource Fixes Extra",
)
